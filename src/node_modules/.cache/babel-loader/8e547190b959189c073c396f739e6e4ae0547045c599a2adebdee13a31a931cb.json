{"ast":null,"code":"var _jsxFileName = \"/home/noxirongky/code/stima/tucil2/src/src/components/CanvasComponents.tsx\",\n  _s = $RefreshSig$();\n// CanvasComponent.tsx\n\nimport React, { useRef, useEffect } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CanvasComponent = ({\n  points,\n  bezierPoints,\n  show\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n\n  // Calculate the minimum values as well\n  let MinWidth = Infinity,\n    MinHeight = Infinity;\n  for (let i = 0; i < points.length; i++) {\n    MinWidth = Math.min(points[i].x, MinWidth);\n    MinHeight = Math.min(points[i].y, MinHeight);\n  }\n  for (let i = 0; i < bezierPoints.length; i++) {\n    MinWidth = Math.min(bezierPoints[i].x, MinWidth);\n    MinHeight = Math.min(bezierPoints[i].y, MinHeight);\n  }\n  let MaxWidth = 0,\n    MaxHeight = 0;\n  for (let i = 0; i < points.length; i++) {\n    MaxWidth = Math.max(points[i].x, MaxWidth);\n    MaxHeight = Math.max(points[i].y, MaxHeight);\n  }\n  for (let i = 0; i < bezierPoints.length; i++) {\n    MaxWidth = Math.max(bezierPoints[i].x, MaxWidth);\n    MaxHeight = Math.max(bezierPoints[i].y, MaxHeight);\n  }\n  const padding = 40;\n  const paddedWidth = 400 - padding * 2;\n  const paddedHeight = 400 - padding * 2;\n\n  // Normalize to center the curve\n  const Normalize = (num, which) => {\n    const range = which === \"w\" ? MaxWidth - MinWidth : MaxHeight - MinHeight;\n    const scale = which === \"w\" ? paddedWidth : paddedHeight;\n    return padding + (num - (which === \"w\" ? MinWidth : MinHeight)) / range * scale;\n  };\n  const drawGrid = (context, width, height) => {\n    const gridSize = Math.min(width / 10, height / 10);\n    context.strokeStyle = \"#cbd5e1\";\n\n    // Draw vertical grid lines\n    for (let x = 0; x <= width; x += gridSize) {\n      context.beginPath();\n      context.moveTo(x, 0);\n      context.lineTo(x, height);\n      context.stroke();\n    }\n\n    // Draw horizontal grid lines\n    for (let y = 0; y <= height; y += gridSize) {\n      context.beginPath();\n      context.moveTo(0, y);\n      context.lineTo(width, y);\n      context.stroke();\n    }\n  };\n  const drawLine = (context, start, end, color = \"black\") => {\n    context.beginPath();\n    context.moveTo(Normalize(start.x, \"w\"), Normalize(start.y, \"h\"));\n    context.lineTo(Normalize(end.x, \"w\"), Normalize(end.y, \"h\"));\n    context.strokeStyle = color;\n    context.stroke();\n  };\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (canvas) {\n      const context = canvas.getContext(\"2d\");\n      if (context) {\n        // Clear the canvas\n        context.clearRect(0, 0, 400, 400);\n\n        // Draw the grid\n        drawGrid(context, 400, 400);\n\n        // Draw the segments\n        for (let i = 0; i < points.length - 1; i++) {\n          drawLine(context, points[i], points[i + 1], \"blue\");\n        }\n\n        // Draw the bezier curve\n        for (let i = 0; i < bezierPoints.length - 1; i++) {\n          drawLine(context, bezierPoints[i], bezierPoints[i + 1], \"red\");\n        }\n      }\n    }\n  }); // Redraw when points, bezierPoints, width, or height change\n\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    width: 400,\n    height: 400,\n    className: \"bg-zinc-100\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 123,\n    columnNumber: 5\n  }, this);\n};\n_s(CanvasComponent, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = CanvasComponent;\nexport default CanvasComponent;\nvar _c;\n$RefreshReg$(_c, \"CanvasComponent\");","map":{"version":3,"names":["React","useRef","useEffect","jsxDEV","_jsxDEV","CanvasComponent","points","bezierPoints","show","_s","canvasRef","MinWidth","Infinity","MinHeight","i","length","Math","min","x","y","MaxWidth","MaxHeight","max","padding","paddedWidth","paddedHeight","Normalize","num","which","range","scale","drawGrid","context","width","height","gridSize","strokeStyle","beginPath","moveTo","lineTo","stroke","drawLine","start","end","color","canvas","current","getContext","clearRect","ref","className","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/noxirongky/code/stima/tucil2/src/src/components/CanvasComponents.tsx"],"sourcesContent":["// CanvasComponent.tsx\nimport { watch } from \"fs\";\nimport React, { useRef, useEffect } from \"react\";\n\ntype Point = {\n  x: number;\n  y: number;\n};\n\ninterface CanvasProps {\n  points: Point[];\n  bezierPoints: Point[];\n  show: boolean;\n}\n\nconst CanvasComponent: React.FC<CanvasProps> = ({\n  points,\n  bezierPoints,\n  show,\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  // Calculate the minimum values as well\n  let MinWidth = Infinity,\n    MinHeight = Infinity;\n  for (let i = 0; i < points.length; i++) {\n    MinWidth = Math.min(points[i].x, MinWidth);\n    MinHeight = Math.min(points[i].y, MinHeight);\n  }\n\n  for (let i = 0; i < bezierPoints.length; i++) {\n    MinWidth = Math.min(bezierPoints[i].x, MinWidth);\n    MinHeight = Math.min(bezierPoints[i].y, MinHeight);\n  }\n\n  let MaxWidth = 0,\n    MaxHeight = 0;\n  for (let i = 0; i < points.length; i++) {\n    MaxWidth = Math.max(points[i].x, MaxWidth);\n    MaxHeight = Math.max(points[i].y, MaxHeight);\n  }\n\n  for (let i = 0; i < bezierPoints.length; i++) {\n    MaxWidth = Math.max(bezierPoints[i].x, MaxWidth);\n    MaxHeight = Math.max(bezierPoints[i].y, MaxHeight);\n  }\n  const padding = 40;\n  const paddedWidth = 400 - padding * 2;\n  const paddedHeight = 400 - padding * 2;\n\n  // Normalize to center the curve\n  const Normalize = (num: number, which: \"w\" | \"h\") => {\n    const range = which === \"w\" ? MaxWidth - MinWidth : MaxHeight - MinHeight;\n    const scale = which === \"w\" ? paddedWidth : paddedHeight;\n    return (\n      padding + ((num - (which === \"w\" ? MinWidth : MinHeight)) / range) * scale\n    );\n  };\n\n  const drawGrid = (\n    context: CanvasRenderingContext2D,\n    width: number,\n    height: number\n  ) => {\n    const gridSize = Math.min(width / 10, height / 10);\n    context.strokeStyle = \"#cbd5e1\";\n\n    // Draw vertical grid lines\n    for (let x = 0; x <= width; x += gridSize) {\n      context.beginPath();\n      context.moveTo(x, 0);\n      context.lineTo(x, height);\n      context.stroke();\n    }\n\n    // Draw horizontal grid lines\n    for (let y = 0; y <= height; y += gridSize) {\n      context.beginPath();\n      context.moveTo(0, y);\n      context.lineTo(width, y);\n      context.stroke();\n    }\n  };\n\n  const drawLine = (\n    context: CanvasRenderingContext2D,\n    start: Point,\n    end: Point,\n    color: string = \"black\"\n  ) => {\n    context.beginPath();\n    context.moveTo(Normalize(start.x, \"w\"), Normalize(start.y, \"h\"));\n    context.lineTo(Normalize(end.x, \"w\"), Normalize(end.y, \"h\"));\n    context.strokeStyle = color;\n    context.stroke();\n  };\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (canvas) {\n      const context = canvas.getContext(\"2d\");\n      if (context) {\n        // Clear the canvas\n        context.clearRect(0, 0, 400, 400);\n\n        // Draw the grid\n        drawGrid(context, 400, 400);\n\n        // Draw the segments\n        for (let i = 0; i < points.length - 1; i++) {\n          drawLine(context, points[i], points[i + 1], \"blue\");\n        }\n\n        // Draw the bezier curve\n        for (let i = 0; i < bezierPoints.length - 1; i++) {\n          drawLine(context, bezierPoints[i], bezierPoints[i + 1], \"red\");\n        }\n      }\n    }\n  }); // Redraw when points, bezierPoints, width, or height change\n\n  return (\n    <canvas ref={canvasRef} width={400} height={400} className=\"bg-zinc-100\" />\n  );\n};\n\nexport default CanvasComponent;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}